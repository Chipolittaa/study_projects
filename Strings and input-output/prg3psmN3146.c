#include <stdio.h>  // для ввода-вывода
#include <stdlib.h> // для работы с realloc(), malloc()
#include <string.h> // для работы функции strcmp()

int is_digit(const char c)
{                                // функция проверки символа на принадлежность множеству цифр
    return c >= '0' && c <= '9'; // если код символа лежит между кодами символов 0 и 9, то это цифра
}

int info() // функция для вывода информации о студенте
{
    printf("Махрова Полина Степановна, гр. N3146\nВариант: 1-2-3-4\n");
    return 0;
}

int read(char *input, char *output, int c_flag, int n_flag, int m, int n) // функция для чтения данных
{
    size_t text_size = 0, ipv4_size = 0, i = 0;
    int c;                           // text_size = размер переданного текста, ipv4_size - размер массива, содержащего индексы найденных адресов, с - вспомогательная переменная для чтения данных, i - переменная для осуществления прохода по всему переданному тексту
    char *text = NULL;                // создаем указатель на динамический массив со всем текстом
    size_t *ipv4s = NULL; // создаем указатель на динамически массив с индексами адресов
    if (strcmp(input, ""))            // если строка input оказалась непустой, то значит, что можно прочитать текст из файла
    {
        FILE *input_file = fopen(input, "r");  // открывается файл для чтения
        while ((c = fgetc(input_file)) != EOF) // цикл до конца файла (читаем посимвольно)
        {
            text = (char *)realloc(text, ++text_size); // расширение динамического массива со всем текстом
            if (!text)                                 // если realloc вернул пустой указатель, то произошла ошибка выделения памяти. выводим соответствующее сообщение об ошибке и прекращаем работу функции с кодом 4
            {
                fprintf(stderr, "Ошибка выделения памяти.\n");
                return 4;
            }
            text[text_size - 1] = c; // если расширение прошло успешно, то считанный символ копируется в массив
        }
        fclose(input_file); // после чтения нужно закрыть файл
    }
    else // если строка input пустая, то ввод осуществляется из стандартного потока ввода
    {
        while ((c = getchar()) != EOF) // цикл до конца текста (в Unix и Linux системах это сочетание ctrl + D)
        {
            text = (char *)realloc(text, ++text_size); // расширение массива
            if (!text)                                 // если не получилось, то выводится сообщение об ошибке и функция прекращает свою работу
            {
                fprintf(stderr, "Ошибка выделения памяти.\n");
                return 4;
            }
            text[text_size - 1] = c; // если все расширение прошло успешно, то считанный символ копируется в массив
        }
    }

    int current = 0;      // создается переменная для отслеживания действующей последовательности, которая является ipv4-адресом
    while (i < text_size) // цикл по всем символам текста
    {
        if (is_digit(text[i])) // если встречена цифра, то, возможно, рассматривается начало ipv4-адреса
        {
            size_t j = i, dot_counter = 0;
            int num = -1, is_valid = 0; // j - индекс, который будет проходить по потенциальному адресу, dot_counter - счетчик точек, разделяющих числа адреса (их должно быть три), num - число между точками, is_valid - флаг для отслеживания валидности рассматриваемой последовательности
            while (j < text_size)       // цикл, пока не будет достигнут конец текста или не закончена последовательность предполагаемого адреса
            {
                if (is_digit(text[j])) // если встречена цифра, то выполняется данный блок
                {
                    if (num == 0 && text[j] == '0') break; // проверка условия наличия адреса с ведущими нулями. если такие есть, то цикл по последовательности прерывается
                    num = (num == -1) ? 0 : num;           // если число изначально было инициализировано -1 (-1 не может быть частью адреса, поэтому используется это значение), то num присваивается значение нуля
                    num *= 10;                             // увеличивается разрядность числа
                    num += text[j] - '0';                  // к числу прибавляется числовое значение рассматриваемой цифры
                }
                else if (text[j] == '.') // если же встречена точка, то выполняется данный код
                {
                    if (num == -1) break; // если подряд идет несколько точек, то можно прервать чтение
                    if (dot_counter == 3 && num != -1) // если была встречена точка, перед который уже размещен какой-то корректный ipv4-адрес, то числу num присваивается значение 256 для дальнейших взаимодействий
                    {
                        num = 256;
                    }
                    else // в противном случае:
                    {
                        dot_counter++; // счетчик точек увеличивается на 1
                        if (num < 256)
                            num = -1; // если число перед точкой входит в диапазон чисел для ipv4, то оно приводится в начальное значение
                        else
                            break; // в противном случае рассматривается уже не ipv4-адрес, и цикл по последовательности можно прекратить
                    }
                }
                else if (text[j] == '\n' && !n_flag && text[j - 1] != '\n')
                   ; // если же встречен символ перевода строки и при этом не вводилась опция -n, то никакие действия не совершаются
                else  // во всех остальных случаях выполняется этот код
                {
                    is_valid = (dot_counter == 3 && num != -1); // проверяется условие равенства количества встреченных точек и наличия каких-то цифр после третьей точки. если оба условия выполняется, то встречен нужный адрес
                    current += is_valid;                        // если это корректный адрес, то общее число найденных адресов увеличивается
                    while (!is_digit(text[j])) j--;             // цикл к последнему цифровому символу
                    j++;                                        // переходим на следующий (нецифровой)
                    break;                                      // цикл прекращается
                }

                if (dot_counter == 3 && (num >= 256 || j >= text_size - 1)) // если встречено три точки и при этом после третьей точки расположено число, превышающее 256 или рассматривается предпоследний или последний символ текста, то выполняется этот блок
                {
                    is_valid = (num != -1);             // если после третьей точки есть число, то рассматривается адрес
                    current += is_valid;                // количество последовательностей увеличивается, если рассматривается корректный адрес
                    if (num >= 256)                     // если последнее число больше 255, то выполняется этот код
                    {
                        j--;                            // переходим к предыдущему символу 
                        while (!is_digit(text[j])) j--; // цикл к последней цифре
                        j++;                            // переход на следующий символ
                    }
                    break;                              // цикл прерывается
                }
                j++; // переход к следующему символу
            }

            if (is_valid && m <= current && n >= current)
            {
                ipv4_size += 2;                                               // увеличивается количество элементов в ipv4s
                ipv4s = (size_t *)realloc(ipv4s, ipv4_size * sizeof(size_t)); // выделение памяти под новые индексы
                if (!ipv4s)                                                   // в случае ошибки выводится соответствующее сообщение и функция завершает работу
                {
                    fprintf(stderr, "Ошибка выделения памяти.\n");
                    return 4;
                }
                ipv4s[ipv4_size - 2] = i;                                                     // сначала вводится индекс начала последовательности
                ipv4s[ipv4_size - 1] = j - (j == text_size - 1 && is_digit(text[j]) ? 0 : 1); // потом индекс конца. конструкция с тернарным оператором проверяет случай, когда последний символ вводимого текста является цифрой, ведь в таком случае уменьшать j на 1 не надо
            }
            if (is_valid)
                i = j - 1; // если встречена корректная последовательность, то повторно ее рассматривать не нужно. i увеличивается до состояние j - 1
        }
        i++; // переход к следующему символу
    }

    int ind = 0;            // переменная для отслеживания начала / конца последовательности. если ind четный, то рассматривается начало последовательности, иначе - конец.
    if (strcmp(output, "")) // если файл для вывода был передан, то выполняется данный блок кода
    {
        FILE *output_file = fopen(output, "w");            // открывается файл для записи (если его не было, то создается новый. если он уже был, то содержимое очищается)
        for (size_t i = 0; i < text_size; ++i) // цикл по всему тексту
        {
            if (ipv4s) // если найдена хотя бы одна подходящая последовательность, то выполняется этот блок
            {
                if (ipv4s[ind] == i && ind % 2 == 0) // если встретился индекс начала последовательности, то начинается выделение
                {
                    if (c_flag) // либо устанавливается код цвета
                        fprintf(output_file, "\033[34m");
                    else // либо выводится символ для разметки Markdown
                        fprintf(output_file, "`");
                    ind++; // переход к новому индексу в ipv4s
                }
            }
            fputc(text[i], output_file); // печатается символ последовательности
            if (ipv4s)
            {
                if (ipv4s[ind] == i) // если встречается индекс конца последовательности, то выделение заканчивается
                {
                    if (c_flag) // сбрасывается код цвета
                        fprintf(output_file, "\033[0m");
                    else // выводится символ для разметки
                        fprintf(output_file, "`");
                    ind++; // переход к новому индексу в ipv4s
                }
            }
        }
        fclose(output_file); // после записи необходимо закрыть файл
    }
    else // если же файл для вывода не передавался, то все выводится в назначенный поток вывода. все аналогично предыдущему блоку
    {
        for (size_t i = 0; i < text_size; ++i)
        {
            if (ipv4s)
            {
                if (ipv4s[ind] == i && ind % 2 == 0)
                {
                    if (c_flag)
                        printf("\033[34m");
                    else
                        printf("`");
                    ind++;
                }
            }
            putchar(text[i]);
            if (ipv4s)
            {
                if (ipv4s[ind] == i && ind % 2 == 1)
                {
                    if (c_flag)
                        printf("\033[0m");
                    else
                        printf("`");
                    ind++;
                }
            }
        }
    }
    free(ipv4s); // очистка памяти от массива с индексами
    free(text);  // очистка памяти от массива с текстом
    return 0;    // в случае успешного выполнения функция возвращает код 0
}

int main(int argc, char *argv[]) // argc - количество переданных аргументов (>=1), *argv[] - переданные аргументы (argv[0] - имя программы)
{
    char *input = "", *output = "";                          // строки для входного и выходного файлов
    unsigned c_flag = 0, n_flag = 0, m = 0, n = __INT_MAX__; // c_flag - флаг для -c, n_flag - для  -n, m и n - значения для -f и -t
    for (int i = 1; i < argc; ++i)                           // цикл по всем переданным аргументам
    {
        if (argv[i][0] == '-') // если первый символ аргумента -, то это значит, что пользователь пытается ввести опцию
        {
            if (argv[i][1] == 'f') // если передавалась фунция -f, то происходит чтение переданного числа
            {
                sscanf(argv[i], "-f=%d", &m);
                if (!m && strcmp(argv[i], "-f=0")) // если не удалось прочитать (m = 0, а передавался не 0), то выводится сообщение об ошибке и программа завершает работу с кодом 1
                {
                    fprintf(stderr, "Ошибка: не удалось записать число для опции -f.\n");
                    return 1;
                }
            }
            else if (argv[i][1] == 't') // аналогично для функции -t
            {
                sscanf(argv[i], "-t=%d", &n);
                if (n == __INT_MAX__)
                {
                    fprintf(stderr, "Ошибка: не удалось записать число для опции -t.\n");
                    return 1;
                }
            }
            else if (!strcmp(argv[i], "-n")) // если передавалась опция -n, то поднимается флаг n_flag
            {
                n_flag = 1;
            }
            else if (!strcmp(argv[i], "-c")) // если передавалась опция -с, то поднимается флаг с_flag
            {
                c_flag = 1;
            }
            else if (!strcmp(argv[i], "-v")) // если передавалась опция -v, то выполняется функция info() и программа завершает работу с кодом 0
            {
                return info();
            }
            else // если вводится неизвестная опция, то выводится соответствующее сообщение и программа завершает работу с кодом 2
            {
                fprintf(stderr, "Ошибка: опция '%s' не поддерживается.\n", argv[i]);
                return 2;
            }
        }
        else if (fopen(argv[i], "r") && !strcmp(input, "")) // если передавалось имя файла, и при этом строка с файлом для чтения пустая, то значит, что ввелось название файла для чтения
        {
            input = argv[i];
        }
        else if (!strcmp(output, "") && strcmp(input, "")) // если файл для чтения уже введен, но встречено еще одно имя файла, то значит, что передалось имя файла для вывода
        {
            output = argv[i];
        }
        else // в противном случае выводится сообщение об ошибке
        {
            fprintf(stderr, "Ошибка: не удалось открыть файл %s.\n", argv[i]);
            return 3;
        }
    }
    return read(input, output, c_flag, n_flag, m, n); // вызывается фунция read(). программа завершает работу с тем кодом, который возвращает функция после своего выполнения
}